/**
 * 同步器示例
 * synchronized
 *  对象锁：synchronized 取的锁都是对象锁，而不是把一段代码或方法当作锁
 *  同步实例方法是对当前对象加锁、同步静态方法是对当前类对象加锁、同步方法块是对某一个对象加锁。synchronized(this) 是对当前对象加锁，synchronized(class) 是对类对象加锁
 *  锁不同方法：多线程访问同一个对象的不同同步方法时仍需要排队，因为是对象锁
 *  锁重入：已经获取了对象锁的线程，在释放锁之前，可以再次获取该对象锁。如果锁不可重入，很容易就可以造成死锁。 可重入锁也支持父子继承关系
 *  锁释放：异常会导致锁自动释放
 *  锁继承：同步锁无法继承
 *  锁细化：可以利用同步方法块+锁非 this 对象缩小同步范围，以提升多线程执行效率
 *  锁特例：
 *      注意字符串常量池中的 String 常量具有缓存特性，用作锁时要注意相同字符串是同一把锁
 *      不同的内置类或静态内置类是不同的对象锁
 *  死锁问题：不同线程都在等待不可能被释放的锁，从而导致各自任务都无法继续完成。{@link }
 *      可以使用 JDK 工具监测是否有死锁现象：jps + jstack 查看 deadlock 关键词
 *  volatile 关键字：volatile 关键字可以保证变量在多个线程间的可见性，但是不能保证原子性，所以不能用来保证线程安全
 *      synchronized 可以间接保证可见性。{@link cn.willow.demo.concurrent.synchronizers.SynchronizedOverVolatileDemo}
 *          如果对静态变量操作和检查的静态同步方法都添加了 synchronized，那么这个静态变量就不必再用 volatile 关键字修饰了。
 *          synchronized 同步块可以让多个线程发生上下文切换，间接让主存和线程工作内存同步刷新。它具有互斥性和可见性，它不仅可以解决一个线程看到对象处于不一致的状态，还可以保证进入同步方法或同步代码块的每个线程，都看到由同一把锁保护之前所有的修改效果
 *      特例：双重检查锁定（Double-Checked Locking）是一种用于实现延迟初始化的模式，特别是在实现单例模式时。它旨在减少同步的开销，同时确保线程安全。
 *          volatile 在这种情况下禁止JVM和处理器对 volatile 变量的读写操作进行重排序。这对于确保对象正确初始化至关重要，因为对象的构造过程可能涉及多个步骤，而 volatile 确保这些步骤按照正确的顺序执行。
 *  AtomicInteger 原子类：原子类可以保证原子性，但是不能保证可见性。而且原子类只能保证单个原子操作方法的原子性，多个原子操作方法之间的调用无法保证原子性，此时必须要用同步
 * @author willow
 * @date 2024/12/10
 */
package cn.willow.demo.concurrent.synchronizers;